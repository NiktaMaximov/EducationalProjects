**Класс Thread** <br/>
Для создания потока, необходимо предоставить метод, который поток будет выполнять.
Метод может содержать, либо не содержать параметры, чтобы обернуть ти методы, предоставялются два делегата
+ ThreadStart
+ ParameterizedThreadStart

**Преимущество потоков**
+ Дочерние потоки могут быть использованы для освобождения основного потока
+ Потоки можно использовать для разбиения задач на мелкие подзадачи, которые могут выполняться параллельно

**Недостатки потоков**
+ При большшом кол-ве потоков трудно отлаживать и поддерживать код
+ Создание потоков нагружает систему относительно ресурсов памяти и процессора
+ Необходимо выполнять обработку исключений внутри фоновых методов, так как любые необработанные исключения могут привести к сбоям

**Класс ThreadPool** <br/>
Пул потоков поддерживает опитимальное кол-во потоков и динамически связывает их с конкретными задачами.
По завершению работы потоки возращаются в пул, где привязываются к новым задачам.
Каждый пул потоков поддерживает минимальное и максимальное количество потоков, эти значения можно изменять, вызывая следующиме статические методы:
+ ThreadPool.SetMinThreads;
+ ThreadPool.SetMaxThreads;

**Преимущество ThreadPool**
+ Дочерние потоки могут быть использованы для освобождения основного потока
+ Оптимально потоки создаются и поддерживаются с помощью CLR

**Недостатки ThreadPool**
+ При большшом кол-ве потоков трудно отлаживать и поддерживать код
+ Необходимо выполнять обработку исключений внутри фоновых методов, так как любые необработанные исключения могут привести к сбоям

**Класс BackgroundWorker** <br/>
BackgroundWorker - это компонент, предоставленный в NET для создания управляемых потоков в ThreadPool

**Класс Task** <br/>
Класс Task - способ асинхронного выполнения работы по аналогии с потоком из `ThreadPool`, и он базируется на **асинхронном шаблоне, основанном на задачах (TAP)**.
Базовый класс `Task` не возращает результат, если необходимо вернуть результат, следует обращаться к `Task<T>`.<br/>
`Task.Factory.StartNew` - создает задачу, выполнение которой планируется внутри `ThreadPool`. <br/>
`Task.Delay(кол-во мс)` - ожидание задачи, работает асинхронно и не использует циклы процессора.

**Отмена задач**<br/>
Платформа NET включает два класс для отмены задача:
+ CancellationTokenSource - этот класс отвечает за создание меток отмены и передачу всем меткам, запроса на отмену
+ CancellationToken - исполльзуется "слушателями" для мониторинга текущего состояния запроса

**Ожидание выполнения задач**<br/>
`Task.Wait()` - ожидание одной задачи<br/>
`Task.WaitAll()` - ожидание выполнения всех указанных задач<br/>
`Task.WaitAny()` - ожидание нескольких задач, но для продолжения достаточно выполнения любой из переданных задач<br/>
`Task.WhenAll()` - вариация метод `WaitAll()` но без блокировки вызывающего потока, данный метод возращает задачу, которая запускает ожидание для всех указанных задач<br/>
`Task.WhenAny()` - вариация метод `WaitAny()` но без блокировки вызывающего потока, данный метод возращает задачу, которая запускает ожидание любой из указанных задач<br/>

**Родительские и дочерние задачи**<br/>
Дочерняя задача, создается в качестве вложенной задачи внутри родительской. Дочерняя задача может создоваться как присоединенная или отсоидененная.
Оба типа задач создаются внутри родительской, однако по умолчанию все созданные задачи являются отсоединенными.
Чтобы сделать задачу присоединенной. необходимо установить для ее свойства `AttachedToParent` значение `true`

**Класс Parallel**<br/>
Класс поддерживает параллелизм обработки данных. При выполнении параллельного цикла, TPL разбивает исходную коллекцию на части, таким образом, чтобы
каждая часть выполнялась одновременно и независимо. Планирование задач выполняется классом `TaskSchedular`, который учитывает системные ресурсы и нагрузку на процессор
при разделении на части.<br/>
Существует три способа преобразования последовательности кода в паралельный:
+ при помощи метода `Parallel.Invoke`
+ при помощи метода `Parallel.For`
+ при помощи метода `Parallel.ForEach`

Метод `Parallel.Invoke` - принимает массив функций в качестве параметров и выполняет их, хотя не гарантирует полную параллельность их исполнения (выполнять задачу паралелльно или последовательно решает `TaskSheduler`)<br/>
Метод `Parallel.For` - вариант цикла `for` при котором итерации выполняются параллельно, данный метод возращает экземпляр класса `ParallelLoopResult`, содержащий состояние цикла после его завершения<br/>

**Степень параллелизма**<br/>
Степень параллелизма - определяет максимальное количество задач, которые могут быть созданы параллельными циклами (по умлочанию равно 64).
Настраивается с помощью свойства `MaxDegreeOfParallelism`, которое является частью класса `ParallelOptions`

**Отмена циклов**<br/>
В параллельных циклах нельзя использовать `break` и `continue` поскольку выполение таких циклов происходит в нескольких потоках или задачах.
Для прерывания параллельных циклов необходимо использовать класс `ParallelLoopState`  (`Parallel.Break`, `ParallelLoopState.Stop` ) а для отмены - `CancellationToken` и `ParallelOptions`


**PLINQ**<br/>
PLINQ - является паралелльной реализацией LINQ<br/>
Класс `ParallelEnumerable` помимо поддержки стандартных операций запроса LINQ, поддерживает множество других методов параллельного исполнения:
+ `AsParallel()` - преобразует последовательный LINQ запрос в параллельный
+ `AsSequential()` - активирует последовательное выполение запроса
+ `AsOrder()` - сохранение порядка выполения задач
+ `AsUnorder()` - противоположность `AsOrder()`
+ `ForAll()` - обеспечивает параллельное выполние запроса
+ `Aggregate()` - применяет функцию к запросу, которая объеденяет результаты работы параллельных задач
+ `WithDegressOfParallelism()` - возможность указать максимальное количество задач, используемых для параллельного запроса
+ `WithExecuteMode()` - используя этот метод, можно принудительно выполнить запрос в параллельном режиме, или позволить PLINQ решить как он будет выполняться, параллельно или последовательно

**Объеденение данных в PLINQ**<br/>
При создании параллельного запроса исходная коллекция разделяется на части, как только запрос завершиться результаты должны быть объеденены так, чтобы были доступны потоку потрибителю.
+ Параметр объеденения `NotBuffered` - результат отдельных задача не сохраняется в буфер, а сразу возращается потребителю
+ Параметр объеденения `AutoBuffered` - результаты всех задача помещаются в буфер, который переодически становится доступным для потребителя
+ Параметр объеденения `FullyBuffered` - результаты задач помещаются в буфер, прежде чем поток-потребитель получит к ним доступ

**Примитивы синхронизации**<br/>
*Критическая секция* - это участок кода, который должен быть защищен от паралелльного доступа для сохранения работоспособности. Например - запись данных в файл<br/>
*Примитивы синхронизации* - простые программные механизмы платформы более низкого уровня (т.е. ОС), которые помогают в реализации многопоточности на уровне ядра ОС.
Распростроненными примерами примитивов являются:
+ Блокировки
+ Мьютексы
+ Условные переменные
+ Семафоры

Примитивы синхронизации можно разделить на пять категорий:
+ Операции со взаимоблокировкой
+ Блокирующие
+ Сигнальные
+ Типы с облегченной синхронизацией
+ SpinWait

**Барьеры доступа к памяти** <br/>
Барьеры памяти гарантируют, что операторы располоденные ДО и ПОСЛЕ барьера не будут его пересекать, сохроняя порядок исполнения.
Существуют три барьера памяти:
+ Барьер записи - не пропускает через себя операции записи значений в память
+ Барьер чтения - не пропускает через себя операции чтения, но не ограничивает операции записи
+ Полный барьер - обеспечивает сохранение порядка, не пропуская оперцаии чтения и записи

**Блокировка, мьютекс и семафор** <br/>
Блокирующие конструкции `lock` и мьютекс (mutex) позволяют только одному потоку получить доступ к защищенному ресурсу.
Lock - это реализация быстрого вызова, которая использует высокоуровневый класс синхронизации под названием `Monitor`. <br/>
Семфафор - блокирующая конструкция, которая позволяет заданному количеству потоков получить доступ к защищенному ресурсу 

**Сигнальные примитивы** <br/>
Благодоря сигнальным примитивам поток-потребитель останавливается до тех пор пока не получит сигнал от от потока-производителя.
Существуют следующие сигнальные приметивы:
+ `Thread.Join` - вызывающий поток блокируется, пока не завершиться присоединенный поток
+ `WaitHadles` 
+ `EventWaitHandlers` - предоставляет событие синхронизации для потока и служит базовым классом для `AutoResetEvent` и `ManualResetEvent`. <br/>
Можно оповещать EventWaitHandlers вызывая `Set()` или `SignalAndWait()`

**События Barrier и CountDownEvent** <br/>
`CountDownEvent` - относится к событию, которое возникает, когда его счетчик становится равным 0 <br/>
`Barrier` - Позволяет нескольким потокам работать без главного контролирующего потока

**SpinWait и SpinLock** <br/>
Для создания объекта `SpinWait` можно воспользоваться конструкцией
```
var spin = new SpinWiat();
```
Для обращения к `spin` вызываем данную команду
```
spin.SpinOnce();
```

**Параллельные очереди** <br/>
**Производительность `Queue<T>` по сравнению с `ConcurrentQueue<T>`** <br/>
Следует использовать `ConcurrentQueue<T>` в следующих сценариях, в которых будет небольшое или значительное преимущество в производительности перед `Queue<T>`
+ В чистом сценариипроизводитель-потребитель с незначительным временем обработки каждого элемента
+ В чистом сценариипроизводитель-потребитель, в которм будет только один поток-производитель и один поток-потребитель
+ В чистых, а также смешанных сценариях производитель-потребитель, в которых время обработки состовляет более 500 ФЛОПС, если время обработки меньше, то лучше использовать `Queue<T>`

`ConcurrentBagExample` в отличие от `ConcurrentStack` и `ConcurrentQueues` которые сортируют элементы при их хранении и извлечении, является неупорядоченной коллекцией.
Данный тип оптимизирован для сценариев, в которых одни и те же потоки работают как производители и как потребители. 

**Использование `BlockingCollection<T>`** <br/>
Класс `BLockingCollection` является потокобезопасной коллекцией, реализующей интерфейс `IProduceConsumerCollection<T>`.
Можно одновременно добавлять и удалять элементы из коллекции, при этом не думаю о синхронизации - она обеспечивается автоматически. <br/>
Существуют два важных аспекта блокировки коллекций:
+ ограничение (Bounding) - означает, что можно привязать коллекцию к максимальному значению, после которого новые значения уже не смогут добавится, при этом поток-производитель переходит в спящий режим
+ блокировка (Blocking) -означает, что можно заблокировать поток-потребитель, когда коллекция станет пустой

**Отложенная инициализация** <br />
Отложенная инициализация - распростроненный в прикладном программировании шаблон проектирования, при котором создание объекта откладывается до тех пор пока он не потребуется в приложении. <br/>

**Сокращение издержок при помощи отложенной инициализации** <br/>
`Lazy<T>` использует непрямое обращение к объекту с помощью дополнительной обертки, что может привести к проблемам с вычислениями и памятью.
Чтобы избежать создание лишней обертки, можно использовать статический вариант класса `Lazy<T>` а именно `LazyInitializer`. <br/>
Можно использовать `LazyInitializer.EnsureInitialized` для инициализации данных которые передаются через ссылку или фукнцию инициализации

**Асинхронное программирование** <br/>
Когда не следует использовать асинхронное программирование:
+ В базе данных без пула обработки подключений
+ Когда важно читабельность кода
+ Для простых и быстрых операций
+ Для приложения с большим кол-ом разделяемых данных

Когда следует использовать асинхронный код:
+ Ведение журанала событий
+ Запросы к внешним серверам
+ Создание отзывчивых пользовательских интерфейсов
+ Приложения, требовательные к ЦП

Ключеове словой `await` обеспечивает следующее:
+ Метод выполняется асинхронно
+ Вызывающий поток разблокируется, возращается в пул и обрабатывает другие клиентские запросы
+ Когда выполнение заканчивается, `ThreadPool` получит сигнал прерывания от процессора, который начнет извлекать из пула свободный поток
+ Получив ответ, поток из `ThreadPool` начинает выполнять остальную часть кода


